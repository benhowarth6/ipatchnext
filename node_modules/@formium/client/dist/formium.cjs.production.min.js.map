{"version":3,"file":"formium.cjs.production.min.js","sources":["../src/errors.ts","../src/index.ts"],"sourcesContent":["/**\n * Copyright (c) Formium, Inc. and its affiliates.\n *\n * This source code is licensed under the Business Source License license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * This error is thrown when there is an API error with a payload. The error\n * body includes the data that came in the payload plus status and a server\n * message. When it's a rate limit error in includes `retryAfter`\n */\nexport class APIError extends Error {\n  status: number;\n  serverMessage: string;\n  link?: string;\n  action?: string;\n  retryAfter: number | null | 'never';\n  [key: string]: any;\n\n  constructor(message: string, response: Response, body?: object) {\n    super();\n    this.message = `${message} (${response.status})`;\n    this.status = response.status;\n    this.serverMessage = message;\n    this.retryAfter = null;\n\n    if (body) {\n      for (const field of Object.keys(body)) {\n        if (field !== 'message') {\n          // @ts-ignore\n          this[field] = body[field];\n        }\n      }\n    }\n\n    if (response.status === 429) {\n      const retryAfter = response.headers.get('Retry-After');\n      if (retryAfter) {\n        this.retryAfter = parseInt(retryAfter, 10);\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Formium, Inc. and its affiliates.\n *\n * This source code is licensed under the Business Source License license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport 'cross-fetch/polyfill';\nimport qs from 'query-string';\nimport { APIError } from './errors';\nimport { Submit, User, Form, Project } from '@formium/types';\n\n/**\n * Create a wrapper around fetch() with API base URL and default headers.\n *\n * @param fetchImplementation - Fetch implmementation (useful of debugging/testing)\n * @param baseUrl - Base API URL\n *\n * @public\n */\nexport function _createFetcher(\n  baseUrl: string,\n  fetchImplementation: typeof fetch,\n  apiToken?: string\n) {\n  return function fetcher(endpoint: string, options: RequestInit = {}) {\n    let opts = options;\n    opts.headers = options.headers || {};\n    (opts.headers as any)['X-Formik-Client'] = '@formium/client';\n    (opts.headers as any)['X-Formik-Client-Version'] = __VERSION__;\n    if (apiToken) {\n      (opts.headers as any).Authorization = `Bearer ${apiToken}`;\n    }\n\n    return fetchImplementation(baseUrl + endpoint, opts).then(async res => {\n      if (res.ok) {\n        if (!res.headers.get('content-type')) {\n          return;\n        }\n        return res.headers.get('content-type')!.includes('application/json')\n          ? await res.json()\n          : res;\n      }\n\n      let bodyError;\n      let body = await res.json();\n\n      // Some APIs wrongly return `err` instead of `error`\n      bodyError = body.error || body.err || body;\n\n      const msg = bodyError?.message || 'Response Error';\n\n      return Promise.reject(new APIError(msg, res, bodyError));\n    });\n  };\n}\n\n/**\n * Formium Client options\n *\n * @public\n */\nexport interface Options {\n  /** Base URL */\n  baseUrl?: string;\n  /** Custom fetch implementation (useful for mocking) */\n  fetchImplementation?: any;\n  /** API token */\n  apiToken?: string;\n}\n\n/**\n * Submission data.\n *\n * @remarks\n * This can either be a plain JavaScript object or `FormData`. If `FormData` contains files,\n * the submission will be rejected. If your form contains file uploads, please upload them using `formium.uploadFile(formSlug, file)` first, and store the returned URL. For more information about uploads, please refer to `formium.uploadFile`.\n *\n * For security, Formium upholds the following limits on data that you should be aware of:\n *   - The following keys are banned: `pass`, `password`, `pw`, `ssn`, `cc`, `creditCard`, `credit_card`, `creditcard`, `cardNumber`, `cardnumber`, `card_number`.\n *   - Objects with data deeper than 3 levels of nesting will be stringified\n *   - All keys must be shorter than 32 characters\n *   - JSON payloads must be less than 5KB for non-enterprise users\n *\n * Calling `submiForm` with `FormData` instead of an JavaScript object works as well. In addition, if your form contains `<select multiple>`, that value will\n * be automatically converted to an array of strings instead of a comma-delimited string. This is for your convenience.\n *\n * @public\n */\nexport type SubmitData = Record<string, any> | FormData;\n\n/**\n * Submission JSON response shape.\n *\n * @public\n */\nexport interface SubmitSuccess {\n  /** Was the submission successful? */\n  ok: boolean;\n}\n\n/**\n * HTTP client returned by fetch factory\n *\n * @public\n */\nexport type _Fetcher = (\n  endpoint: string,\n  options?: RequestInit\n) => Promise<any>;\n\n/**\n * Results of paginated resource request\n * @public\n */\nexport type Results<T> = {\n  /** List of results returned */\n  data: T[];\n  /** Identifier to return the next item in the sequence */\n  next?: string;\n};\n\n/**\n * Paginated resource query\n * @public\n */\nexport interface PaginatedQuery {\n  /**\n   * Pagination cursor id\n   */\n  from?: string;\n  /**\n   * Number of results to return. Max is 100.\n   */\n  limit?: number;\n}\n/** @public */\nexport interface FindFormsQuery extends PaginatedQuery {\n  /** With given Action id */\n  actionId?: string;\n  /** Return forms that have been updated starting at this date */\n  updateStartAt?: string;\n}\n\n/**  @public */\nexport interface FindSubmitsQuery extends PaginatedQuery {\n  /** With given Form id */\n  formId: string;\n  /** Sort by (-createAt, createAt) */\n  sort?: '-createAt' | 'createAt';\n}\n\n/**  @public */\nexport interface DeleteSubmitsQuery {\n  /** List of Submission ids to delete */\n  ids: string;\n}\n\n/** @public */\nexport interface GetFormQuery {\n  /** The id of the Revision */\n  revisionId?: string;\n}\n\n/**\n * Formium Client\n *\n * @public\n */\nexport class FormiumClient {\n  /** Project ID */\n  projectId: string;\n  /** API endpoint */\n  baseUrl: string;\n  /**  Internal HTTP client */\n  _fetcher: _Fetcher;\n\n  constructor(projectId: string, options?: Options) {\n    this.projectId = projectId;\n    this.baseUrl = options?.baseUrl ?? 'https://api.formium.io';\n    this._fetcher = _createFetcher(\n      this.baseUrl,\n      options?.fetchImplementation ?? fetch,\n      options?.apiToken\n    );\n  }\n\n  /**\n   * Return Forms in a project\n   *\n   * @param query - Query parameters\n   * @param fetchOptions - Additional request options\n   * @returns A list of Forms\n   * @public\n   */\n  findForms(\n    query?: FindFormsQuery,\n    fetchOptions?: RequestInit\n  ): Promise<Results<Form>> {\n    let url =\n      `/v1/form?` + qs.stringify({ projectId: this.projectId, ...query });\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Return the current User (based on the token)\n   * @returns A User\n   * @public\n   */\n  getMe(fetchOptions?: RequestInit): Promise<User> {\n    let url = `/v1/user/me`;\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Return a Project by id\n   *\n   * @param id - Project id\n   * @param fetchOptions - fetch overrides\n   * @returns A Project\n   * @public\n   */\n  getProject(id: string, fetchOptions?: RequestInit): Promise<Project> {\n    let url = `/v1/project/` + id;\n\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Retrieve the Projects the user belongs to\n   * @returns A list of Projects\n   * @public\n   */\n  getMyProjects(fetchOptions?: RequestInit): Promise<Results<Project>> {\n    let url = `/v1/project/me`;\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Delete the current Oauth2 bearer token (for signout)\n   *\n   * @public\n   */\n  logout(fetchOptions?: RequestInit) {\n    let url = `/oauth/token/me`;\n    return this._fetcher(url, {\n      method: 'DELETE',\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Return a Project by slug\n   * @param projectSlug - A Project slug\n   * @returns A Project\n   * @public\n   */\n  getProjectBySlug(\n    projectSlug: string,\n    fetchOptions?: RequestInit\n  ): Promise<Project> {\n    let url = `/v1/project/slug` + projectSlug;\n\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Return a Form based on its slug\n   *\n   * @param formSlug - form slug\n   * @param query - Query parameters\n   * @param fetchOptions - Additional request options\n   * @returns A Form\n   * @public\n   */\n  getFormBySlug(\n    formSlug: string,\n    query?: GetFormQuery,\n    fetchOptions?: RequestInit\n  ): Promise<Form> {\n    let url = `/v1/form/id/${this.projectId}/${formSlug}`;\n    let options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    };\n\n    if (query && query.revisionId) {\n      (options as any).headers['X-Formik-Revision'] = query.revisionId;\n    }\n\n    return this._fetcher(url, options);\n  }\n\n  /**\n   * Return a Submission\n   *\n   * @param submitId - The id of the submission\n   * @param fetchOptions - Additional request options\n   * @returns A Submission\n   * @public\n   */\n  getSubmit(submitId: string, fetchOptions?: RequestInit): Promise<Submit> {\n    let url = `/v1/submit/${submitId}`;\n    let options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    };\n\n    return this._fetcher(url, options);\n  }\n\n  /**\n   * Delete a Submission\n   *\n   * @param submitId - The id of the Submission\n   * @param fetchOptions - Additional request options\n   * @public\n   */\n  deleteSubmit(submitId: string, fetchOptions?: RequestInit): Promise<void> {\n    let url = `/v1/submit/${submitId}`;\n    let options = {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    };\n\n    return this._fetcher(url, options);\n  }\n\n  /**\n   * Delete mulitple Submissions\n   *\n   * @param query - Query parameters\n   * @param fetchOptions - Additional request options\n   * @public\n   */\n  deleteSubmits(\n    query: DeleteSubmitsQuery,\n    fetchOptions?: RequestInit\n  ): Promise<void> {\n    let url = `/v1/submit?` + qs.stringify(query);\n    let options = {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    };\n\n    return this._fetcher(url, options);\n  }\n\n  /**\n   * Find Submissions of a given form\n   *\n   * @param query - Query parameters\n   * @param fetchOptions - Additional request options\n   * @returns A list of Submissions\n   * @public\n   */\n  findSubmits(\n    query: FindSubmitsQuery,\n    fetchOptions?: RequestInit\n  ): Promise<Results<Project>> {\n    let url = `/v1/submit?` + qs.stringify(query);\n    return this._fetcher(url, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    });\n  }\n\n  /**\n   * Return a Form given its id\n   *\n   * @param formSlug - form slug\n   * @param query - Query parameters\n   * @param fetchOptions - Additional request options\n   * @returns A Form entity\n   * @public\n   */\n  getFormById(\n    id: string,\n    query?: GetFormQuery,\n    fetchOptions?: RequestInit\n  ): Promise<Form> {\n    let url = `/v1/form/${id}`;\n    let options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      ...fetchOptions,\n    };\n\n    if (query && query.revisionId) {\n      (options as any).headers['X-Formik-Revision'] = query.revisionId;\n    }\n\n    return this._fetcher(url, options);\n  }\n\n  /**\n   * Submit data to a Form\n   *\n   * @param formSlug - Slug of the Form\n   * @param data - An object or FormData instance containing submission data.\n   * @public\n   */\n  submitForm(formSlug: string, data: SubmitData): Promise<void> {\n    let values: string;\n    // Convert form data into object and handle arrays (i.e. select multiple)\n    if (data instanceof FormData) {\n      let obj: Record<string, any> = {};\n      for (const [key, value] of (data as FormData) as any) {\n        if (!obj.hasOwnProperty(key)) {\n          obj[key] = value;\n          continue;\n        }\n        if (!Array.isArray(obj[key])) {\n          obj[key] = [obj[key]];\n        }\n        obj[key].push(value);\n      }\n      values = JSON.stringify(obj);\n    } else {\n      values = JSON.stringify(data);\n    }\n\n    return this._fetcher(`/submit/${this.projectId}/${formSlug}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: values,\n    });\n  }\n\n  /**\n   * Upload a file to Formium. All uploads are private by default.\n   *\n   * @param formSlug - Slug of the Form\n   * @param file - File to be uploaded\n   * @returns URI of the uploaded file\n   * @public\n   */\n  uploadFile(formSlug: string, file: File): Promise<string | null> {\n    let data = new FormData();\n    data.append('file', file);\n    return this._fetcher(`/submit/${this.projectId}/${formSlug}/upload`, {\n      method: 'POST',\n      body: data,\n    }).then(res => res.headers.get('Location'));\n  }\n}\n\n/**\n * Create a new Formium API client\n *\n * @param projectSlug - Project slug\n * @param options - Client options\n * @returns A FormiumClient\n * @public\n */\nexport function createClient(\n  projectSlug: string,\n  options?: Options\n): FormiumClient {\n  return new FormiumClient(projectSlug, options);\n}\n\nexport * from '@formium/types';\n"],"names":["APIError","message","response","body","status","serverMessage","retryAfter","Object","keys","field","headers","get","parseInt","Error","_createFetcher","baseUrl","fetchImplementation","apiToken","endpoint","options","opts","__VERSION__","Authorization","then","res","json","msg","bodyError","error","err","Promise","reject","ok","includes","FormiumClient","projectId","_fetcher","this","fetch","findForms","query","fetchOptions","url","qs","stringify","method","getMe","getProject","id","getMyProjects","logout","getProjectBySlug","projectSlug","getFormBySlug","formSlug","revisionId","getSubmit","submitId","deleteSubmit","deleteSubmits","findSubmits","getFormById","submitForm","data","values","FormData","obj","key","value","hasOwnProperty","Array","isArray","push","JSON","uploadFile","file","append"],"mappings":"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"}