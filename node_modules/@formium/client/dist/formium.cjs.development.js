'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

require('cross-fetch/polyfill');
var qs = _interopDefault(require('query-string'));
var types = require('@formium/types');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

/**
 * Copyright (c) Formium, Inc. and its affiliates.
 *
 * This source code is licensed under the Business Source License license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * This error is thrown when there is an API error with a payload. The error
 * body includes the data that came in the payload plus status and a server
 * message. When it's a rate limit error in includes `retryAfter`
 */
var APIError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(APIError, _Error);

  function APIError(message, response, body) {
    var _this;

    _this = _Error.call(this) || this;
    _this.message = message + " (" + response.status + ")";
    _this.status = response.status;
    _this.serverMessage = message;
    _this.retryAfter = null;

    if (body) {
      for (var _i = 0, _Object$keys = Object.keys(body); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];

        if (field !== 'message') {
          // @ts-ignore
          _this[field] = body[field];
        }
      }
    }

    if (response.status === 429) {
      var retryAfter = response.headers.get('Retry-After');

      if (retryAfter) {
        _this.retryAfter = parseInt(retryAfter, 10);
      }
    }

    return _this;
  }

  return APIError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * Create a wrapper around fetch() with API base URL and default headers.
 *
 * @param fetchImplementation - Fetch implmementation (useful of debugging/testing)
 * @param baseUrl - Base API URL
 *
 * @public
 */

function _createFetcher(baseUrl, fetchImplementation, apiToken) {
  return function fetcher(endpoint, options) {
    if (options === void 0) {
      options = {};
    }

    var opts = options;
    opts.headers = options.headers || {};
    opts.headers['X-Formik-Client'] = '@formium/client';
    opts.headers['X-Formik-Client-Version'] = "0.1.3";

    if (apiToken) {
      opts.headers.Authorization = "Bearer " + apiToken;
    }

    return fetchImplementation(baseUrl + endpoint, opts).then(function (res) {
      try {
        var _temp3 = function _temp3(_result) {
          if (_exit2) return _result;
          var bodyError;
          return Promise.resolve(res.json()).then(function (body) {
            var _bodyError;

            // Some APIs wrongly return `err` instead of `error`
            bodyError = body.error || body.err || body;
            var msg = ((_bodyError = bodyError) === null || _bodyError === void 0 ? void 0 : _bodyError.message) || 'Response Error';
            return Promise.reject(new APIError(msg, res, bodyError));
          });
        };

        var _exit2 = false;

        var _temp4 = function () {
          if (res.ok) {
            if (!res.headers.get('content-type')) {
              _exit2 = true;
              return;
            }

            _exit2 = true;

            var _res$headers$get$incl2 = res.headers.get('content-type').includes('application/json');

            return _res$headers$get$incl2 ? Promise.resolve(res.json()) : res;
          }
        }();

        return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
      } catch (e) {
        return Promise.reject(e);
      }
    });
  };
}
/**
 * Formium Client
 *
 * @public
 */

var FormiumClient = /*#__PURE__*/function () {
  function FormiumClient(projectId, options) {
    var _options$baseUrl, _options$fetchImpleme;

    this.projectId = projectId;
    this.baseUrl = (_options$baseUrl = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _options$baseUrl !== void 0 ? _options$baseUrl : 'https://api.formium.io';
    this._fetcher = _createFetcher(this.baseUrl, (_options$fetchImpleme = options === null || options === void 0 ? void 0 : options.fetchImplementation) !== null && _options$fetchImpleme !== void 0 ? _options$fetchImpleme : fetch, options === null || options === void 0 ? void 0 : options.apiToken);
  }
  /**
   * Return Forms in a project
   *
   * @param query - Query parameters
   * @param fetchOptions - Additional request options
   * @returns A list of Forms
   * @public
   */


  var _proto = FormiumClient.prototype;

  _proto.findForms = function findForms(query, fetchOptions) {
    var url = "/v1/form?" + qs.stringify(_extends({
      projectId: this.projectId
    }, query));
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Return the current User (based on the token)
   * @returns A User
   * @public
   */
  ;

  _proto.getMe = function getMe(fetchOptions) {
    var url = "/v1/user/me";
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Return a Project by id
   *
   * @param id - Project id
   * @param fetchOptions - fetch overrides
   * @returns A Project
   * @public
   */
  ;

  _proto.getProject = function getProject(id, fetchOptions) {
    var url = "/v1/project/" + id;
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Retrieve the Projects the user belongs to
   * @returns A list of Projects
   * @public
   */
  ;

  _proto.getMyProjects = function getMyProjects(fetchOptions) {
    var url = "/v1/project/me";
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Delete the current Oauth2 bearer token (for signout)
   *
   * @public
   */
  ;

  _proto.logout = function logout(fetchOptions) {
    var url = "/oauth/token/me";
    return this._fetcher(url, _extends({
      method: 'DELETE'
    }, fetchOptions));
  }
  /**
   * Return a Project by slug
   * @param projectSlug - A Project slug
   * @returns A Project
   * @public
   */
  ;

  _proto.getProjectBySlug = function getProjectBySlug(projectSlug, fetchOptions) {
    var url = "/v1/project/slug" + projectSlug;
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Return a Form based on its slug
   *
   * @param formSlug - form slug
   * @param query - Query parameters
   * @param fetchOptions - Additional request options
   * @returns A Form
   * @public
   */
  ;

  _proto.getFormBySlug = function getFormBySlug(formSlug, query, fetchOptions) {
    var url = "/v1/form/id/" + this.projectId + "/" + formSlug;

    var options = _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions);

    if (query && query.revisionId) {
      options.headers['X-Formik-Revision'] = query.revisionId;
    }

    return this._fetcher(url, options);
  }
  /**
   * Return a Submission
   *
   * @param submitId - The id of the submission
   * @param fetchOptions - Additional request options
   * @returns A Submission
   * @public
   */
  ;

  _proto.getSubmit = function getSubmit(submitId, fetchOptions) {
    var url = "/v1/submit/" + submitId;

    var options = _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions);

    return this._fetcher(url, options);
  }
  /**
   * Delete a Submission
   *
   * @param submitId - The id of the Submission
   * @param fetchOptions - Additional request options
   * @public
   */
  ;

  _proto.deleteSubmit = function deleteSubmit(submitId, fetchOptions) {
    var url = "/v1/submit/" + submitId;

    var options = _extends({
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions);

    return this._fetcher(url, options);
  }
  /**
   * Delete mulitple Submissions
   *
   * @param query - Query parameters
   * @param fetchOptions - Additional request options
   * @public
   */
  ;

  _proto.deleteSubmits = function deleteSubmits(query, fetchOptions) {
    var url = "/v1/submit?" + qs.stringify(query);

    var options = _extends({
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions);

    return this._fetcher(url, options);
  }
  /**
   * Find Submissions of a given form
   *
   * @param query - Query parameters
   * @param fetchOptions - Additional request options
   * @returns A list of Submissions
   * @public
   */
  ;

  _proto.findSubmits = function findSubmits(query, fetchOptions) {
    var url = "/v1/submit?" + qs.stringify(query);
    return this._fetcher(url, _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions));
  }
  /**
   * Return a Form given its id
   *
   * @param formSlug - form slug
   * @param query - Query parameters
   * @param fetchOptions - Additional request options
   * @returns A Form entity
   * @public
   */
  ;

  _proto.getFormById = function getFormById(id, query, fetchOptions) {
    var url = "/v1/form/" + id;

    var options = _extends({
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    }, fetchOptions);

    if (query && query.revisionId) {
      options.headers['X-Formik-Revision'] = query.revisionId;
    }

    return this._fetcher(url, options);
  }
  /**
   * Submit data to a Form
   *
   * @param formSlug - Slug of the Form
   * @param data - An object or FormData instance containing submission data.
   * @public
   */
  ;

  _proto.submitForm = function submitForm(formSlug, data) {
    var values; // Convert form data into object and handle arrays (i.e. select multiple)

    if (data instanceof FormData) {
      var obj = {};

      for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            key = _step$value[0],
            value = _step$value[1];

        if (!obj.hasOwnProperty(key)) {
          obj[key] = value;
          continue;
        }

        if (!Array.isArray(obj[key])) {
          obj[key] = [obj[key]];
        }

        obj[key].push(value);
      }

      values = JSON.stringify(obj);
    } else {
      values = JSON.stringify(data);
    }

    return this._fetcher("/submit/" + this.projectId + "/" + formSlug, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: values
    });
  }
  /**
   * Upload a file to Formium. All uploads are private by default.
   *
   * @param formSlug - Slug of the Form
   * @param file - File to be uploaded
   * @returns URI of the uploaded file
   * @public
   */
  ;

  _proto.uploadFile = function uploadFile(formSlug, file) {
    var data = new FormData();
    data.append('file', file);
    return this._fetcher("/submit/" + this.projectId + "/" + formSlug + "/upload", {
      method: 'POST',
      body: data
    }).then(function (res) {
      return res.headers.get('Location');
    });
  };

  return FormiumClient;
}();
/**
 * Create a new Formium API client
 *
 * @param projectSlug - Project slug
 * @param options - Client options
 * @returns A FormiumClient
 * @public
 */

function createClient(projectSlug, options) {
  return new FormiumClient(projectSlug, options);
}

Object.keys(types).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return types[k];
    }
  });
});
exports.FormiumClient = FormiumClient;
exports._createFetcher = _createFetcher;
exports.createClient = createClient;
//# sourceMappingURL=formium.cjs.development.js.map
